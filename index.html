<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Brick Shooter: Nokia Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Roboto:wght@700&display=swap');

        :root {
            /* Nokia Palette */
            --nokia-bg: #8b9c0f;      /* Xanh l√° s√°ng (n·ªÅn LCD) */
            --nokia-dark: #0f380f;    /* Xanh ƒëen (pixel hi·ªÉn th·ªã) */
            --nokia-mid: #306230;     /* Xanh ƒë·∫≠m v·ª´a */
            --nokia-light: #9bbc0f;   /* Xanh nh·∫°t nh·∫•t */
            
            --case-color: #333333;
            --btn-color: #e0e0e0;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #121212;
            font-family: 'Press Start 2P', cursive;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
            touch-action: none; 
            -webkit-user-select: none; 
            user-select: none;
        }

        /* Th√™m class n√†y cho c√°c n√∫t b·∫•m ƒë·ªÉ khi ·∫•n kh√¥ng b·ªã hi·ªán khung xanh */
        button, .btn, .ui-btn {
            -webkit-tap-highlight-color: transparent;
            outline: none;
        }

        /* --- NOKIA PHONE FRAME --- */
        #nokia-phone {
            width: 340px;
            min-height: 100%;
            background-color: var(--case-color);
            border-radius: 40px;
            box-shadow: 
                inset 2px 2px 5px rgba(255,255,255,0.1),
                inset -5px -5px 10px rgba(0,0,0,0.5),
                10px 10px 30px rgba(0,0,0,0.5);
            padding: 20px 20px 40px 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            
            box-sizing: border-box;
            transform-origin: center;
        }

        /* Logo Area */
        .brand {
            font-family: 'Roboto', sans-serif;
            color: #ccc;
            font-size: 18px;
            letter-spacing: 2px;
            margin-bottom: 15px;
            text-transform: uppercase;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
        }

        /* Screen Area */
        .screen-bezel {
            width: 260px;
            height: 370px;
            background-color: #555;
            border-radius: 10px 10px 20px 20px;
            padding: 15px;
            box-shadow: inset 2px 2px 5px rgba(0,0,0,0.6);
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .lcd-container {
            width: 100%;
            height: 100%;
            background-color: var(--nokia-bg);
            border: 2px solid #444;
            box-shadow: inset 1px 1px 4px rgba(0,0,0,0.4);
            position: relative;
            overflow: hidden;
        }

        /* Scanline Effect */
        .lcd-container::after {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%);
            background-size: 100% 4px;
            z-index: 10;
            pointer-events: none;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            /* image-rendering: pixelated; Removed for vector smoothness */
        }

        /* --- CONTROLS --- */
        .controls-area {
            flex-grow: 1;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        /* D-PAD Layout */
        .d-pad {
            position: relative;
            width: 160px;
            height: 160px;
        }

        .btn {
            position: absolute;
            background: linear-gradient(145deg, #555, #333);
            border: none;
            border-radius: 10px; /* Slightly squarish like classic phones */
            box-shadow: 
                3px 3px 5px rgba(0,0,0,0.5),
                inset 1px 1px 2px rgba(255,255,255,0.2);
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 20px;
            transition: transform 0.1s;
            /* Disable selection */
            user-select: none;
            -webkit-user-select: none;
        }

        .btn:active, .btn.pressed {
            transform: translateY(1px);         /* Ch·ªâ d·ªãch xu·ªëng 1px thay v√¨ scale */
            background: linear-gradient(145deg, #444, #333);
            box-shadow: inset 1px 1px 2px rgba(0,0,0,0.4);
        }

        /* Positioning buttons in a cross shape */
        .btn-up { top: 0; left: 35%;  width: 50px; height: 50px; border-radius: 10px 10px 5px 5px; }
        .btn-down { bottom: 0; left: 35%;  width: 50px; height: 50px; border-radius: 5px 5px 10px 10px;}
        .btn-left { top: 30%; left: -20%;  width: 70px; height: 70px; border-radius: 10px 5px 5px 10px;}
        .btn-right { top: 30%; right: -20%;  width: 70px; height: 70px; border-radius: 5px 10px 10px 5px;}
        
        /* Center deco */
        .d-pad-center {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 40px; height: 40px;
            background: #222;
            border-radius: 5px;
        }

        /* --- GAME UI OVERLAYS (INSIDE LCD) --- */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 20;
            color: var(--nokia-dark);
        }

        .screen {
            background-color: rgba(139, 156, 15, 0.9);
            padding: 10px;
            border: 2px solid var(--nokia-dark);
            display: none;
            pointer-events: auto;
            width: 80%;
        }

        .screen.active {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        h1 {
            font-size: 16px;
            margin-bottom: 10px;
            color: var(--nokia-dark);
            text-transform: uppercase;
        }

        p {
            font-size: 10px;
            line-height: 1.4;
            color: var(--nokia-dark);
        }

        /* Retro Button Style */
        .ui-btn {
            background-color: transparent;
            color: var(--nokia-dark);
            border: 2px solid var(--nokia-dark);
            padding: 8px;
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            cursor: pointer;
            text-transform: uppercase;
        }

        .ui-btn:active {
            background-color: var(--nokia-dark);
            color: var(--nokia-bg);
        }

        /* Shop / Responsive Grid */
        #ship-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 8px;
            padding: 8px;
            align-items: start;
        }
        .shop-card {
            background: #0a1f0a;
            border: 2px solid var(--nokia-mid);
            border-radius: 10px;
            padding: 4px;
            text-align: center;
            font-size: 10px;
            cursor: pointer;
            position: relative;
            transition: transform 120ms ease, box-shadow 120ms ease;
            width: 56px;
            min-height: 110px;
            display:flex;
            flex-direction:column;
            justify-content:center;
            align-items:center;
        }
        .shop-card:focus, .shop-card:hover {
            transform: translateY(-4px);
                box-shadow: 0 6px 12px rgba(0,0,0,0.4);
            }
        .shop-card .shop-img { display:block; margin:6px auto; image-rendering:pixelated; width:48px; height:auto }
        .equip-badge { position:absolute; top:8px; right:8px; background:#ffd54f; color:#111; width:18px; height:18px; padding:0; border-radius:50%; font-size:14px; display:flex; align-items:center; justify-content:center; box-shadow:0 2px 4px rgba(0,0,0,0.3); }
        .price-badge { position:absolute; bottom:8px; right:8px; background:#306230; color:#dff5b8; padding:2px 6px; border-radius:6px; font-size:9px; }

        /* Coins badge top-left when in shop */
        .coins-badge {
            position: absolute;
            top: 8px;
            left: 8px;
            background: rgba(0,0,0,0.6);
            color: var(--nokia-light);
            padding: 6px 8px;
            border-radius: 6px;
            font-size: 10px;
            z-index: 40;
            pointer-events: none;
        }

        /* Modal for ship details */
        .shop-modal {
            position: absolute;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 60;
            background: rgba(0,0,0,0.4);
            pointer-events: auto;
        }
        .shop-modal .modal-card {
            background: #0a1f0a;
            border: 2px solid var(--nokia-mid);
            padding: 12px;
            border-radius: 10px;
            width: 70%;
            max-width: 260px;
            text-align: center;
            color: var(--nokia-light);
        }
        .shop-modal .modal-card img { width: 120px; image-rendering:pixelated; display:block; margin:0 auto 8px }
        .shop-modal .modal-actions { display:flex; gap:8px; justify-content:center; margin-top:8px }

        /* Hover / Tap effects for shop buttons */
        .ui-btn.shop-btn:hover { transform: translateY(-3px); box-shadow: 0 6px 10px rgba(0,0,0,0.35); }
        .ui-btn.shop-btn:active { transform: translateY(0) scale(0.98); }


        .hidden { display: none !important; }

        /* Media Queries for small screens */
        @media (max-height: 700px) {
            #nokia-phone {
                transform: scale(0.85);
            }
        }
        
    </style>
    
</head>
<body>

    <div id="nokia-phone">
        <div class="brand">NOKIA</div>
        
        <div class="screen-bezel">
            <div class="lcd-container">
                <canvas id="gameCanvas"></canvas>
                <!-- PRELOAD IMAGES -->
                 <!-- 6 M√ÅY BAY ‚Äì CH·ªà 1 D√íNG DUY NH·∫§T -->
                <img id="ship0" src="assets/classic.png"  alt="Classic"  style="display:none">
                <img id="ship1" src="assets/falcon.png"   alt="Falcon"   style="display:none">
                <img id="ship2" src="assets/viper.png"    alt="Viper"    style="display:none">
                <img id="ship3" src="assets/phantom.png"  alt="Phantom"  style="display:none">
                <img id="ship4" src="assets/raptor.png"   alt="Raptor"   style="display:none">
                <img id="ship5" src="assets/tempest.png"  alt="Tempest"  style="display:none">
                <!-- ENEMY SPRITE -->
                    <img id="enemy0" src="assets/enemy1.png" style="display:none">
                    <img id="enemy1" src="assets/enemy2.png" style="display:none">
                    <img id="enemy2" src="assets/enemy3.png" style="display:none">
                    <img id="enemy3" src="assets/enemy4.png" style="display:none">
                <!-- BOSS SPRITES -->
                <img id="bossImg1" src="assets/boss1.png" style="display:none">
                <img id="bossImg2" src="assets/boss2.png" style="display:none">
                <img id="bossImg3" src="assets/boss3.png" style="display:none">
                <!-- PRELOAD AUDIO -->
                    <audio id="shootSound" preload="auto" src="audios/shoot.wav"></audio>
                    <audio id="explodeSound" preload="auto" src="audios/explode.wav"></audio>
                <!-- START SCREEN -->
                <div id="start-screen" class="ui-layer screen active">
                    <h1>Pixel Pilot</h1>
                    <p>HIGH-SCORE: <span id="menu-highscore">0</span></p>
                    <button class="ui-btn" onclick="game.start()">START</button>
                    <p style="margin-top:5px; font-size: 8px;">MAX LEVELS: 20</p>
                    <button class="ui-btn" onclick="game.showShop()">SHOP</button>
                </div>
                <div id="shop-screen" class="ui-layer screen">
                    <h2 style="font-size:14px;margin-bottom:4px">SHOP</h2>
                    <div class="coins-badge">COINS: <span id="shop-coins">0</span></div>
                    <div id="ship-list"></div>
                    <button class="ui-btn" onclick="game.showMenu()">BACK</button>
                </div>
                <!-- Ship detail modal -->
                <div id="ship-modal" class="shop-modal" style="display:none">
                    <div class="modal-card">
                        <div style="text-align:right"><button class="ui-btn" onclick="game.hideShipModal()" style="font-size:8px;padding:4px">CLOSE</button></div>
                        <img class="modal-img" src="" alt="ship">
                        <div class="modal-name" style="font-size:10px;margin-top:4px"></div>
                        <div class="modal-price" style="font-size:10px;margin-top:4px"></div>
                        <div class="modal-stats" style="font-size:9px;margin-top:4px"></div>
                        <div class="modal-actions"></div>
                    </div>
                </div>
                <!-- GAME OVER SCREEN -->
                <div id="gameover-screen" class="ui-layer screen">
                    <h1>GAME OVER</h1>
                    <p>SCORE: <span id="go-score">0</span></p>
                    <p>BEST: <span id="go-highscore">0</span></p>
                    <button class="ui-btn" onclick="game.start()">ONE MORE GAME?</button>
                    <button class="ui-btn" onclick="game.showMenu()">MENU</button>
                </div>
                <!-- LEVEL UP / MESSAGE -->
                <div id="message-screen" class="ui-layer screen">
                    <h1 id="msg-title">LEVEL UP!</h1>
                    <p id="msg-sub">NEXT WAVE...</p>
                </div>
            </div>
        </div>

        <div class="controls-area">
            <div class="d-pad">
                <div class="d-pad-center"></div>
                <button class="btn btn-up" id="btn-up">‚ñ≤</button>
                <button class="btn btn-left" id="btn-left">‚óÄ</button>
                <button class="btn btn-right" id="btn-right">‚ñ∂</button>
                <button class="btn btn-down" id="btn-down">‚ñº</button>
            </div>
        </div>
    </div>

    <script>
        /**
         * BRICK SHOOTER: NOKIA EDITION
         * Theme: Monochrome LCD (Dark Green on Light Green)
         * Control: D-Pad (4 directions)
         */

        const CONFIG = {
            // Canvas internal resolution (keep small for retro feel)
            CANVAS_WIDTH: 240, 
            CANVAS_HEIGHT: 320,
            FPS: 60,
            COLORS: {
                BG: '#8b9c0f',       // Lightest (Screen)
                MAIN: '#0f380f',     // Darkest (Ink)
                ACCENT: '#306230',   // Dark Grey (Shading)
                HIGHLIGHT: '#8b9c0f' // Transparent/Bg match
            },
            BOSSES: [
                { id: 0, hp: 40, speed: 0.3, shootRate: 120, img: 'bossImg1' },
                { id: 1, hp: 50, speed: 0.4, shootRate: 110, img: 'bossImg2' },
                { id: 2, hp: 60, speed: 0.5, shootRate: 100, img: 'bossImg3' }
                // TH√äM BOSS M·ªöI: { id: 3, hp: 200, speed: 0.6, shootRate: 25, img: 'bossImg4' }
            ],
            // Enemy HP bar appearance
            ENEMY_HP: {
                DEFAULT_COLOR: '#ff4d4d', // red for most
                ARMORED_COLOR: '#ffcc33', // orange/gold for armored
                BOSS_COLOR: '#ffaa00',
                BG_COLOR: '#333333',
                HEIGHT: 4
            },
            PLAYER: {
                WIDTH: 24,
                HEIGHT: 24,
                SPEED: 3,
                COOLDOWN: 15
            },
            MAX_LEVEL: 20
        };

        const TYPES = {
            NORMAL: 'normal',
            ARMORED: 'armored',
            FAST: 'fast',
            SPLITTER: 'splitter',
            SHOOTER: 'shooter',
            HEALER: 'healer',
            POWERUP: 'powerup'
        };

        const POWERUPS = {
            RAPID_FIRE: { id: 0, label: 'R.FIRE', duration: 400 }, 
            MULTI_SHOT: { id: 1, label: 'MULTI', duration: 400 },
            PIERCING:   { id: 2, label: 'PIERCE', duration: 600 },
            SHIELD:     { id: 3, label: 'SHIELD', duration: 800 },
            BOMB:       { id: 4, label: 'BOMB', duration: 0 }, 
            EXTRA_LIFE: { id: 5, label: '1UP', duration: 0 }    
        };

        // --- UTILS ---
        const Utils = {
            randomRange: (min, max) => Math.random() * (max - min) + min,
            randomInt: (min, max) => Math.floor(Math.random() * (max - min + 1) + min),
            checkAABB: (rect1, rect2) => {
                return (rect1.x < rect2.x + rect2.width &&
                        rect1.x + rect1.width > rect2.x &&
                        rect1.y < rect2.y + rect2.height &&
                        rect1.y + rect1.height > rect2.y);
            },
            checkCircleRect: (circle, rect) => {
                let distX = Math.abs(circle.x - rect.x - rect.width / 2);
                let distY = Math.abs(circle.y - rect.y - rect.height / 2);
                if (distX > (rect.width / 2 + circle.r)) return false;
                if (distY > (rect.height / 2 + circle.r)) return false;
                if (distX <= (rect.width / 2)) return true; 
                if (distY <= (rect.height / 2)) return true;
                let dx = distX - rect.width / 2;
                let dy = distY - rect.height / 2;
                return (dx * dx + dy * dy <= (circle.r * circle.r));
            },   
        };

        class Pool {
            constructor(createFn, resetFn) {
                this.pool = [];
                this.createFn = createFn; 
                this.resetFn = resetFn;   
            }
            get() {
                if (this.pool.length > 0) {
                    const item = this.pool.pop();
                    this.resetFn(item);
                    return item;
                }
                return this.createFn();
            }
            release(item) {
                this.pool.push(item);
            }
        }

        // --- GAME OBJECTS ---

        class Particle {
            constructor() { this.active = false; }
            init(x, y, speed) {
                this.x = x; this.y = y;
                this.vx = (Math.random() - 0.5) * speed;
                this.vy = (Math.random() - 0.5) * speed;
                this.life = 1.0;
                this.decay = 0.05;
                this.active = true;
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                this.life -= this.decay;
                if (this.life <= 0) this.active = false;
            }
            draw(ctx) {
                // Dither effect for fade out
                if (this.life > 0.5 || Math.random() > 0.5) {
                    ctx.fillStyle = CONFIG.COLORS.MAIN;
                    ctx.fillRect(this.x, this.y, 2, 2);
                }
            }
        }

        class Bullet {
            constructor() { 
                this.active = false; 
                this.width = 4; 
                this.height = 8; 
            }
            init(x, y, vy, isEnemy = false, isPiercing = false) {
                this.x = x; this.y = y; this.vy = vy; this.vx = 0;
                this.isEnemy = isEnemy; this.active = true;
                this.isPiercing = isPiercing; this.piercedTargets = [];
            }
            update() {
                this.y += this.vy; this.x += this.vx;
                if (this.y < -20 || this.y > CONFIG.CANVAS_HEIGHT + 20 || 
                    this.x < -20 || this.x > CONFIG.CANVAS_WIDTH + 20) {
                    this.active = false;
                }
            }
            draw(ctx) {
                ctx.fillStyle = CONFIG.COLORS.MAIN;
                // Simple rect for bullets in retro style
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }
        }

        class PowerUpItem {
            constructor(x, y, type) {
                this.x = x; this.y = y;
                this.width = 16; this.height = 16;
                this.type = type; this.vy = 1.5; this.active = true;
                this.char = type.label.charAt(0);
            }
            update() {
                this.y += this.vy;
                if (this.y > CONFIG.CANVAS_HEIGHT) this.active = false;
            }
            draw(ctx) {
                // Blinking effect
                if (Math.floor(Date.now() / 150) % 2 === 0) {
                    ctx.strokeStyle = CONFIG.COLORS.MAIN;
                    ctx.strokeRect(this.x, this.y, this.width, this.height);
                    ctx.fillStyle = CONFIG.COLORS.MAIN;
                    ctx.font = '10px "Press Start 2P"';
                    ctx.textAlign = 'center'; 
                    ctx.textBaseline = 'middle';          
                    ctx.fillText(this.char, this.x + this.width/2, this.y + this.height/2); 
                }
            }
        }

        class Enemy {
            constructor() { this.active = false; this.id = Math.random().toString(36); }
            init(x, y, type, level) {
                this.x = x; this.y = y; this.type = type; this.active = true;
                this.width = 24; this.height = 24; this.vx = 0;
                this.visualType = Math.floor(Math.random() * 4);
                let speedBase = 0.8 + (level * 0.1); // Speed scales with level
                
                switch(type) {
                    case TYPES.ARMORED: this.hp = 3 + Math.floor(level/5); this.vy = 0.5 * speedBase; break;
                    case TYPES.FAST:    this.hp = 1; this.vy = 1.3 * speedBase; break;
                    case TYPES.SPLITTER:this.hp = 1; this.vy = 1.0 * speedBase; break;
                    case TYPES.SHOOTER: this.hp = 2; this.vy = 0.8 * speedBase; this.shootTimer = 150; break;
                    case TYPES.HEALER:  this.hp = 3; this.vy = 0.6 * speedBase; this.healTimer = 120; break;
                    case TYPES.POWERUP: this.hp = 1; this.vy = 1.2 * speedBase; break;
                    default:            this.hp = 1; this.vy = 1.0 * speedBase;
                }
                this.visualType = Math.floor(Math.random() * 4);
                this.maxHp = this.hp;
                this.scale = 0.12; 
            }
            update(game) {
                this.y += this.vy;
                this.x += this.vx;

                if (this.type === TYPES.SHOOTER) {
                    this.shootTimer--;
                    if (this.shootTimer <= 0) {
                        game.spawnEnemyBullet(this.x + 10, this.y + 20);
                        this.shootTimer = 120 + Utils.randomInt(0, 100);
                    }
                }

                if (this.type === TYPES.HEALER) {
                    this.healTimer--;
                    if (this.healTimer <= 0) {
                        game.healNeighbors(this);
                        this.healTimer = 180;
                    }
                }

                if (this.y > CONFIG.CANVAS_HEIGHT + 50) this.active = false;
            }

            takeDamage(dmg) {
                this.hp -= dmg;
                return this.hp <= 0;
            }
            update(gameInstance) {
                this.y += this.vy; this.x += this.vx;

                if (this.type === TYPES.SHOOTER) {
                    this.shootTimer--;
                    if (this.shootTimer <= 0) {
                        gameInstance.spawnEnemyBullet(this.x + this.width/2 - 2, this.y + this.height);
                        this.shootTimer = 200 - (gameInstance.level * 5); // Shoot faster at higher levels
                    }
                }
                if (this.type === TYPES.HEALER) {
                    this.healTimer--;
                    if (this.healTimer <= 0) {
                        gameInstance.healNeighbors(this);
                        this.healTimer = 180; 
                    }
                }
                if (this.y > CONFIG.CANVAS_HEIGHT) { 
                    gameInstance.playerHit();
                    this.active = false;
                }
                if (this.x < 0 || this.x + this.width > CONFIG.CANVAS_WIDTH) this.vx = -this.vx;
            }

            draw(ctx) {
                if (this.type === TYPES.HEALER) {
                    ctx.fillStyle = CONFIG.COLORS.MAIN;
                    ctx.fillRect(this.x+8, this.y+4, 8, 16);
                    ctx.fillRect(this.x+2, this.y+8, 20, 8);
                    return;
                    }
                    if (this.type === TYPES.POWERUP) {
                        ctx.strokeStyle = CONFIG.COLORS.MAIN;
                        ctx.strokeRect(this.x+4, this.y+4, 16, 16);
                        ctx.fillStyle = CONFIG.COLORS.MAIN;
                        ctx.font = '10px "Press Start 2P"';
                        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                        ctx.fillText('?', this.x + this.width/2, this.y + this.height/2);
                        return;
                    }

                // D√ôNG KI·ªÇU ƒê√É CH·ªåN T·ª™ L√öC SPAWN ‚Äì KH√îNG ƒê·ªîI N·ªÆA!
                const enemyImg = document.getElementById(`enemy${this.visualType}`);
                const drawSize = 35;

                ctx.save();
                ctx.translate(this.x + this.width/2, this.y + this.height/2);
                ctx.rotate(Math.PI);

                if (enemyImg && enemyImg.complete) {
                    ctx.drawImage(enemyImg, -drawSize/2, -drawSize/2, drawSize, drawSize);
                } else {
                    // Fallback vector n·∫øu ·∫£nh ch∆∞a load
                    const colors = [
                        {body:'#8bac0f',wing:'#306230'},
                        {body:'#ff6b6b',wing:'#ff8e8e'},
                        {body:'#4ecdc4',wing:'#44a08d'},
                        {body:'#45b7d1',wing:'#96c93d'},
                        {body:'#f9ca24',wing:'#f0932b'},
                        {body:'#eb4d4b',wing:'#6c5ce7'}
                    ][this.visualType];
                    Utils.drawVectorPlane(ctx, 0, 0, 0.13, Math.PI, true, colors);
                }
                ctx.restore();

                // HP bar (gi·ªØ nguy√™n)
                if (this.maxHp > 1) {
                    const hpBarWidth = 20;
                    const hpBarHeight = 4;
                    const hpBarX = this.x + (this.width - hpBarWidth) / 2;
                    const hpBarY = this.y - hpBarHeight - 2;

                    ctx.fillStyle = CONFIG.COLORS.MAIN;
                    ctx.fillRect(hpBarX, hpBarY, hpBarWidth, hpBarHeight);

                    ctx.fillStyle = CONFIG.COLORS.FOREGROUND;
                    ctx.fillRect(hpBarX, hpBarY, hpBarWidth * (this.hp / this.maxHp), hpBarHeight);
                }
            }
        }
        class Boss {
            constructor(game) {
                this.game = game;
                this.active = false;
                this.hp = 1;
                this.maxHp = 1;
                this.x = 0; this.y = -100;
                this.width = 25; this.height = 25;
                this.vy = 0; this.vx = 0;
                this.shootTimer = 0;
                this.bossId = 0;
                this.startTime = 0;
            }

            spawn(level) {
                const bossIndex = Math.floor((level - 1) / 5);
                const bossConfig = CONFIG.BOSSES[bossIndex] || CONFIG.BOSSES[0];
                
                this.bossId = bossConfig.id;
                this.hp = this.maxHp = bossConfig.hp;
                this.vy = bossConfig.speed || 0.5;   // C√ì DI CHUY·ªÇN XU·ªêNG T·ª™ TR√äN
                this.shootTimer = bossConfig.shootRate;
                
                this.x = (CONFIG.CANVAS_WIDTH - this.width) / 2;
                this.y = -this.height;   // B·∫ÆT ƒê·∫¶U T·ª™ NGO√ÄI M√ÄN (nh∆∞ ƒë·ªãch th∆∞·ªùng)
                
                this.active = true;
                this.game.bossActive = true;
                this.game.playSound('powerup');
                this.startTime = Date.now();
            }

            update() {
                if (!this.active) return;

                // === CH·ªà D·ª™NG KHI XU·∫§T HI·ªÜN FULL M√ÄN (y >= 20) ===
                if (this.y < 20) {
                    this.y += this.vy;  
                } else {
                    this.y = 20;        
                    this.vy = 0;        
                }

                // SWING QUA L·∫†I KHI ƒê√É FULL
                if (this.y >= 20) {
                    const swingSpeed = 0.8;  // T·ªëc ƒë·ªô v·ª´a ph·∫£i, ƒë·∫πp
                    const elapsed = (Date.now() - this.startTime) * 0.001;  // Th·ªùi gian t·ª´ l√∫c spawn
                    const amplitude = (CONFIG.CANVAS_WIDTH - this.width) / 2 - 10;

                    // Boss b·∫Øt ƒë·∫ßu t·ª´ gi·ªØa ‚Üí swing ƒë·ªÅu 2 b√™n
                    this.x = (CONFIG.CANVAS_WIDTH - this.width) / 2 
                            + Math.sin(elapsed * swingSpeed) * amplitude;

                    // Ch·ª´a 10px m·ªói b√™n (nh∆∞ b·∫°n mu·ªën)
                    this.x = Math.max(10, Math.min(CONFIG.CANVAS_WIDTH - this.width - 10, this.x));
                }

                // B·∫ÆN ƒê·∫†N
                this.shootTimer--;
                if (this.shootTimer <= 0) {
                    this.game.spawnEnemyBullet(this.x + 20, this.y + this.height);
                    this.game.spawnEnemyBullet(this.x + this.width - 20, this.y + this.height);
                    this.game.spawnEnemyBullet(this.x + this.width/2, this.y + this.height - 10);
                    this.shootTimer = CONFIG.BOSSES[this.bossId]?.shootRate || 60;
                }
            }

            takeDamage(dmg) {
                this.hp -= dmg;
                this.game.spawnExplosion(this.x + Math.random() * this.width, 
                                    this.y + Math.random() * this.height);
                
                if (this.hp <= 0) {
                    this.game.addCoins(50);
                    this.active = false;
                    this.game.bossActive = false;
                    this.game.addScore(500);
                    setTimeout(() => {
                        this.game.playSound('explosion');
                    }, 300); // 300ms = 0.3 gi√¢y
                    this.game.spawnPowerUp(this.x + this.width/2, this.y + this.height/2);
                    setTimeout(1500);
                    return true;
                }
                return false;
            }

            draw(ctx) {
                if (!this.active) return;

                const drawSize = 60;  // ho·∫∑c 24, 28 t√πy √Ω

                ctx.save();
                ctx.translate(this.x + this.width/2, this.y + this.height/2);
                ctx.rotate(Math.PI);  // xoay 180¬∞

                // D√ôNG enemyImage HO·∫∂C boss ri√™ng ƒë·ªÅu ƒë∆∞·ª£c
                const img = document.getElementById(`bossImg${this.bossId + 1}`) || enemyImage;

                ctx.drawImage(img, -drawSize/2, -drawSize/2, drawSize, drawSize);
                ctx.restore();

                // HP BAR NH·ªé THEO
                if (this.maxHp > 1) {
                    const barWidth = drawSize - 8;
                    const barHeight = 3;
                    const barX = this.x + (this.width - barWidth)/2;
                    const barY = this.y - barHeight - 10;
                    const hpRatio = this.hp / this.maxHp;

                    ctx.fillStyle = '#222';
                    ctx.fillRect(barX, barY, barWidth, barHeight);
                    ctx.fillStyle = '#ffaa00';
                    ctx.fillRect(barX, barY, barWidth * hpRatio, barHeight);
                    ctx.strokeStyle = CONFIG.COLORS.MAIN;
                    ctx.lineWidth = 1.5;
                    ctx.strokeRect(barX, barY, barWidth, barHeight);
                }
            }
        }
        class Player {
            constructor(game) {
                this.game = game;
                this.width = CONFIG.PLAYER.WIDTH;
                this.height = CONFIG.PLAYER.HEIGHT;
                this.x = CONFIG.CANVAS_WIDTH / 2 - this.width / 2;
                this.y = CONFIG.CANVAS_HEIGHT - 60;
                this.speed = CONFIG.PLAYER.SPEED;
                this.cooldown = 0;
                this.powerUps = {};
                this.shield = false;
                this.speed = game.currentShip.speed;
                this.fireDelay = game.currentShip.fireRate;
                this.piercing = game.currentShip.piercing;
            }

            update(input) {
                // X Axis
                if (input.keys['ArrowLeft']) this.x -= this.speed;
                if (input.keys['ArrowRight']) this.x += this.speed;
                // Y Axis (Logic m·ªõi)
                if (input.keys['ArrowUp']) this.y -= this.speed;
                if (input.keys['ArrowDown']) this.y += this.speed;

                // Boundaries
                if (this.x < 0) this.x = 0;
                if (this.x + this.width > CONFIG.CANVAS_WIDTH) this.x = CONFIG.CANVAS_WIDTH - this.width;
                if (this.y < 0) this.y = 0;
                if (this.y + this.height > CONFIG.CANVAS_HEIGHT) this.y = CONFIG.CANVAS_HEIGHT - this.height;

                // Timers
                for (let key in this.powerUps) {
                    if (this.powerUps[key] > 0) {
                        this.powerUps[key]--;
                        if (this.powerUps[key] <= 0) {
                            if (key == POWERUPS.SHIELD.id) this.shield = false;
                            delete this.powerUps[key];
                        }
                    }
                }

                // Auto Fire (pause while game is in transition/message)
                if (this.cooldown > 0) this.cooldown--;
                if (this.cooldown <= 0 && !this.game.inTransition) this.shoot();
            }

            shoot() {
                let fireRate = this.hasPowerUp(POWERUPS.RAPID_FIRE) ? 8 : CONFIG.PLAYER.COOLDOWN;
                this.cooldown = fireRate;
                let isPiercing = this.hasPowerUp(POWERUPS.PIERCING);
                let cx = this.x + this.width/2;

                if (this.hasPowerUp(POWERUPS.MULTI_SHOT)) {
                    this.game.spawnPlayerBullet(cx - 2, this.y, 0, isPiercing); 
                    this.game.spawnPlayerBullet(cx - 10, this.y + 10, -1.5, isPiercing);
                    this.game.spawnPlayerBullet(cx + 6, this.y + 10, 1.5, isPiercing);
                } else {
                    this.game.spawnPlayerBullet(cx - 2, this.y, 0, isPiercing);
                }
                this.game.playSound('shoot');
            }

            draw(ctx) {
                const scale = 1.5;  // ‚Üê Thay s·ªë n√†y ƒë·ªÉ ƒëi·ªÅu ch·ªânh ƒë·ªô to: 1.3 ‚Üí 2.0 ƒë·ªÅu ƒë·∫πp!

                const drawW = this.width * scale;
                const drawH = this.height * scale;
                const drawX = this.x + this.width/2 - drawW/2;
                const drawY = this.y + this.height/2 - drawH/2;

                // V·∫º M√ÅY BAY TO ƒê·∫∏P
                ctx.drawImage(game.currentShip.img, drawX, drawY, drawW, drawH);

                // SHIELD T·ª∞ ƒê·ªòNG TO THEO M√ÅY BAY
                if (this.shield) {
                    ctx.strokeStyle = CONFIG.COLORS.MAIN;
                    ctx.lineWidth = 2;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    const radius = (this.width * scale)/2 + 10;
                    ctx.arc(this.x + this.width/2, this.y + this.height/2, radius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }

            activatePowerUp(type) {
                if (type.id === POWERUPS.EXTRA_LIFE.id) {
                    this.game.lives++;
                } else if (type.id === POWERUPS.BOMB.id) {
                    this.game.triggerBomb(this.x, this.y);
                } else if (type.id === POWERUPS.SHIELD.id) {
                    this.shield = true;
                }
                if (type.duration > 0) this.powerUps[type.id] = type.duration;
                this.game.playSound('powerup');
            }
            hasPowerUp(type) { return this.powerUps[type.id] > 0; }
        }

        // --- GAME ENGINE ---

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.canvas.width = CONFIG.CANVAS_WIDTH;
                this.canvas.height = CONFIG.CANVAS_HEIGHT;
                this.ctx = this.canvas.getContext('2d');
                
                this.input = { keys: {} };
                this.setupInputs();

                this.bulletPool = new Pool(() => new Bullet(), (b) => b.active = true);
                this.particlePool = new Pool(() => new Particle(), (p) => p.active = true);
                this.enemyPool = new Pool(() => new Enemy(), (e) => { e.active = true; e.vx = 0; });

                this.state = 'MENU';
                this.score = 0;
                this.highscore = localStorage.getItem('nokia_bs_highscore') || 0;
                document.getElementById('menu-highscore').innerText = this.highscore;

                // Sound Synth
                this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                // Flag to prevent spawning during level transitions/messages
                this.inTransition = false;
                // Flag to avoid multiple scheduling for next level
                this.nextLevelPending = false;
                this.coins = parseInt(localStorage.getItem('nokia_bs_coins') || '1410');
                this.unlockedShips = JSON.parse(localStorage.getItem('nokia_bs_ships') || '[0]');
                this.currentShipId = parseInt(localStorage.getItem('nokia_bs_current') || '0');
                this.currentShip = SHIPS[this.currentShipId];
            }

            setupInputs() {
                // === Keyboard (PC) ===
                window.addEventListener('keydown', e => this.input.keys[e.code] = true);
                window.addEventListener('keyup',   e => this.input.keys[e.code] = false);

                // === D-Pad (Mobile + PC) ‚Äì SI√äU M∆Ø·ª¢T ===
                const bindBtn = (id, code) => {
                    const btn = document.getElementById(id);

                    const press = (e) => {
                        if (e.cancelable) e.preventDefault();   // Ch·∫∑n zoom, cu·ªôn
                        this.input.keys[code] = true;
                        btn.classList.add('pressed');
                    };

                    const release = () => {
                        this.input.keys[code] = false;
                        btn.classList.remove('pressed');
                    };

                    // Mobile: touch (ƒë·ªô tr·ªÖ th·∫•p nh·∫•t)
                    btn.addEventListener('touchstart', press,  { passive: false });
                    btn.addEventListener('touchend',   release, { passive: false });

                    // PC: chu·ªôt (fallback)
                    btn.addEventListener('mousedown', press);
                    btn.addEventListener('mouseup',   release);
                    btn.addEventListener('mouseleave', release);
                };

                bindBtn('btn-up',    'ArrowUp');
                bindBtn('btn-down',  'ArrowDown');
                bindBtn('btn-left',  'ArrowLeft');
                bindBtn('btn-right', 'ArrowRight');
            }

            start() {
                if (this.audioCtx.state === 'suspended') this.audioCtx.resume();
                this.score = 0;
                this.lives = 5;
                this.level = 5;
                this.bullets = [];
                this.enemies = [];
                this.boss = null;
                this.bossActive = false;
                this.particles = [];
                this.powerUpItems = [];
                this.player = new Player(this);
                
                this.initLevel(1);

                this.state = 'PLAYING';
                document.querySelectorAll('.screen').forEach(el => el.classList.remove('active'));
                // üîä UNLOCK AUDIO ON MOBILE (iOS/Android)
                const unlockAudio = () => {
                    if (this.audioCtx.state === 'suspended') this.audioCtx.resume();
                    document.getElementById('shootSound').play().then(() => {
                        document.getElementById('shootSound').pause();
                    }).catch(() => {});
                };
                document.addEventListener('touchstart', unlockAudio, {once: true});
                document.addEventListener('click', unlockAudio, {once: true});
                
                this.lastTime = performance.now();
                requestAnimationFrame(t => this.loop(t));
            }

            initLevel(lvl) {
                this.level = lvl;
                // Level Logic: 20 Levels
                // Enemies count increases
                // Spawn rate decreases (faster spawns)
                
                let baseCount = 10 + (lvl * 2);
                let baseRate = Math.max(20, 70 - (lvl * 2));

                this.waveData = {
                    count: baseCount,
                    spawnTimer: 0,
                    spawnRate: baseRate,
                    totalEnemies: baseCount
                };
                
                if (lvl > 1) {
                    this.showMessage(`LEVEL ${lvl}`);
                }
            }

            showMessage(text) {
                const msg = document.getElementById('message-screen');
                document.getElementById('msg-title').innerText = text;
                msg.classList.add('active');
                
                // Mark transition
                this.inTransition = true;
                // Stop & reset shoot sound immediately so it doesn't bleed into the transition
                try {
                    const s = document.getElementById('shootSound');
                    if (s) { s.pause(); s.currentTime = 0; }
                } catch(e) {}
                // Pause other audio during transition
                this.pauseAudio();
                setTimeout(() => {
                    msg.classList.remove('active');
                    this.inTransition = false;
                    this.resumeAudio();
                }, 1000);
            }

            // Pause audio playback and suspend audio context
            pauseAudio() {
                try {
                    // Suspend WebAudio context n·∫øu c√≥
                    if (this.audioCtx && this.audioCtx.state === 'running') {
                        this.audioCtx.suspend().catch(() => {});
                    }
                } catch (e) {}
                
                // Pause DOM audio v·ªõi Promise ƒë·ªÉ tr√°nh interrupt error
                const pauseAudioEl = (id) => {
                    try {
                        const audio = document.getElementById(id);
                        if (audio) {
                            audio.pause().catch(() => {});  // B·∫Øt l·ªói Promise
                        }
                    } catch(e) {}
                };
                pauseAudioEl('shootSound');
                pauseAudioEl('explodeSound');
            }

            // Resume audio context so sounds can play again
            resumeAudio() {
                try {
                    if (this.audioCtx && this.audioCtx.state === 'suspended') {
                        this.audioCtx.resume().catch(() => {});
                    }
                } catch (e) {}
                // We do not auto-play DOM audio; they will play on-demand after resume
            }

            spawnEnemy() {
                // T·ª∞ CH·ªåN LO·∫†I THEO LEVEL (KH√îNG NG·∫™U NHI√äN)
                let type;
                if(this.level < 3) type = TYPES.NORMAL;
                else if(this.level < 6) type = Math.random() < 0.5 ? TYPES.NORMAL : TYPES.FAST;
                else if(this.level < 10) type = Math.random() < 0.4 ? TYPES.NORMAL : TYPES.ARMORED;
                else if(this.level < 15) type = Math.random() < 0.3 ? TYPES.FAST : TYPES.SHOOTER;
                else type = Math.random() < 0.5 ? TYPES.ARMORED : TYPES.SPLITTER;

                const e = this.enemyPool.get();
                e.init(Utils.randomInt(20, CONFIG.CANVAS_WIDTH - 40), -30, type, this.level);
                this.enemies.push(e);
            }

            manageWaves() {
                // Kh√¥ng l√†m g√¨ khi ƒëang chuy·ªÉn m√†n
                if (this.inTransition) return;

                // ƒêANG C√ì ƒê·ªäCH TRONG WAVE ‚Üí ti·∫øp t·ª•c sinh
                if (this.waveData.count > 0) {
                    if (this.nextLevelPending) this.nextLevelPending = false;
                    this.waveData.spawnTimer--;
                    if (this.waveData.spawnTimer <= 0) {
                        this.spawnEnemy();
                        this.waveData.spawnTimer = this.waveData.spawnRate;
                        this.waveData.count--;
                    }
                    return;
                }

                // WAVE ƒê√É H·∫æT + KH√îNG C√íN ƒê·ªäCH TR√äN M√ÄN
                if (this.enemies.length === 0 && !this.bossActive) {
                    // CHECK XEM C√ì PH·∫¢I LEVEL CHIA H·∫æT CHO 5 KH√îNG ‚Üí SPAWN BOSS
                    if (this.level % 5 === 0 && !this.boss) {
                        // T·∫°o boss m·ªôt l·∫ßn duy nh·∫•t
                        this.boss = new Boss(this);
                        this.boss.spawn(this.level);
                        return; // D·ª´ng l·∫°i, ch·ªù gi·∫øt boss
                    }

                    // ƒê√É GI·∫æT XONG BOSS HO·∫∂C KH√îNG PH·∫¢I LEVEL BOSS ‚Üí chuy·ªÉn level
                    if (!this.nextLevelPending) {
                        this.nextLevelPending = true;
                        setTimeout(() => {
                            this.addCoins(30);
                            this.nextLevelPending = false;
                            this.boss = null; // Reset boss

                            if (this.level < CONFIG.MAX_LEVEL) {
                                this.initLevel(this.level + 1);
                            } else {
                                // Victory loop (endless level 20)
                                this.initLevel(20);
                                this.waveData.spawnRate = 15; // Insane mode
                            }
                        }, 1200); // TƒÉng delay 1.2s cho ho√†nh tr√°ng
                    }
                }
            }

            addCoins(amount) {
                this.coins += amount;
                localStorage.setItem('nokia_bs_coins', this.coins);
            }
           
            // ... (Movement, Collision, Draw logic mostly same but adapted for Nokia colors)

            update() {
                this.manageWaves();
                this.player.update(this.input);

                // === UPDATE BOSS (TH√äM ƒêO·∫†N N√ÄY) ===
                if (this.boss && this.boss.active) {
                    this.boss.update();

                    // Bullet vs Boss
                    this.bullets.forEach(b => {
                        if (b.active && !b.isEnemy && Utils.checkAABB(b, this.boss)) {
                            if (this.boss.takeDamage(1)) {
                                this.addScore(500); // Bonus gi·∫øt boss
                                this.spawnPowerUp(this.boss.x + 60, this.boss.y + 60);
                            }
                            if (!b.isPiercing) b.active = false;
                        }
                    });

                    // Player va ch·∫°m v·ªõi Boss
                    if (Utils.checkAABB(this.player, this.boss)) {
                        this.playerHit();
                    }
                }
                // === K·∫æT TH√öC BOSS ===

                // Update Entities (gi·ªØ nguy√™n)
                [this.bullets, this.enemies, this.particles, this.powerUpItems].forEach(arr => {
                    for (let i = arr.length - 1; i >= 0; i--) {
                        let ent = arr[i];
                        ent.update(this);
                        if (!ent.active) {
                            arr.splice(i, 1);
                            if (ent instanceof Bullet) this.bulletPool.release(ent);
                            if (ent instanceof Particle) this.particlePool.release(ent);
                            if (ent instanceof Enemy) this.enemyPool.release(ent);
                        }
                    }
                });

                // === Collisions (gi·ªØ nguy√™n, ch·ªâ th√™m 1 d√≤ng n·∫øu c·∫ßn) ===
                this.bullets.forEach(b => {
                    if (b.active && !b.isEnemy) {
                        this.enemies.forEach(e => {
                            if (e.active && Utils.checkAABB(b, e)) {
                                if (e.takeDamage(1)) {
                                    e.active = false;
                                    this.addScore(e.type);
                                    this.spawnExplosion(e.x + 12, e.y + 12);
                                    if (e.type === TYPES.SPLITTER) this.splitEnemy(e);
                                    if (e.type === TYPES.POWERUP || Math.random() < 0.05) this.spawnPowerUp(e.x, e.y);
                                }
                                if (!b.isPiercing) b.active = false;
                            }
                        });
                    }
                    if (b.active && b.isEnemy) {
                        if (Utils.checkAABB(b, this.player)) {
                            this.playerHit();
                            b.active = false;
                        }
                    }
                });

                // Player vs Enemy/Powerup (gi·ªØ nguy√™n)
                this.enemies.forEach(e => {
                    if (e.active && Utils.checkAABB(e, this.player)) {
                        this.playerHit();
                        e.active = false;
                        this.spawnExplosion(e.x+12, e.y+12);
                    }
                });
                this.powerUpItems.forEach(p => {
                    if (p.active && Utils.checkAABB(p, this.player)) {
                        this.player.activatePowerUp(p.type);
                        p.active = false;
                    }
                });
            }

            draw() {
                this.ctx.fillStyle = CONFIG.COLORS.BG;
                this.ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);
                
                this.powerUpItems.forEach(p => p.draw(this.ctx));
                this.player.draw(this.ctx);
                this.enemies.forEach(e => e.draw(this.ctx));
                
                // === V·∫º BOSS (TH√äM ƒêO·∫†N N√ÄY) ===
                if (this.boss && this.boss.active) {
                    this.boss.draw(this.ctx);
                }
                // === K·∫æT TH√öC ===

                this.bullets.forEach(b => b.draw(this.ctx));
                this.particles.forEach(p => p.draw(this.ctx));

                // HUD (gi·ªØ nguy√™n)
                this.ctx.fillStyle = CONFIG.COLORS.MAIN;
                this.ctx.font = '10px "Press Start 2P"';
                this.ctx.textAlign = 'left';
                this.ctx.fillText(`LVL ${this.level}`, 5, 12);
                this.ctx.textAlign = 'right';
                this.ctx.fillText(`${this.score.toString().padStart(6, '0')}`, CONFIG.CANVAS_WIDTH - 5, 12);
                
                for(let i=0; i<this.lives; i++) {
                    this.ctx.fillRect(5 + (i*10), CONFIG.CANVAS_HEIGHT - 12, 8, 8);
                }

                // === HI·ªÇN TH·ªä "BOSS" TR√äN HUD (T√ôY CH·ªåN, SI√äU NG·∫¶U) ===
                if (this.boss && this.boss.active) {
                    this.ctx.fillStyle = '#8b9c0f';
                    this.ctx.font = '12px "Press Start 2P"';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('BOSS', CONFIG.CANVAS_WIDTH / 2, 20);
                }
            }

            spawnPlayerBullet(x, y, vx, isPiercing) {
                const b = this.bulletPool.get();
                b.init(x, y, -5, false, isPiercing);
                b.vx = vx;
                this.bullets.push(b);
            }
            spawnEnemyBullet(x, y) {
                const b = this.bulletPool.get();
                b.init(x, y, 3, true, false);
                this.bullets.push(b);
            }
            spawnExplosion(x, y) {
                this.playSound('explosion');
                for(let i=0; i<8; i++) {
                    const p = this.particlePool.get();
                    p.init(x, y, 3);
                    this.particles.push(p);
                }
            }
            spawnPowerUp(x, y) {
                const keys = Object.keys(POWERUPS);
                const k = keys[Math.floor(Math.random() * keys.length)];
                const p = new PowerUpItem(x, y, POWERUPS[k]);
                this.powerUpItems.push(p);
            }
            splitEnemy(parent) {
                for(let d = -1; d <= 1; d+=2) {
                    const e = this.enemyPool.get();
                    e.init(parent.x, parent.y, TYPES.NORMAL, this.level);
                    e.vx = d * 2; e.scale = 0.08;
                    this.enemies.push(e);
                }
            }
            healNeighbors(healer) {
                this.enemies.forEach(e => {
                    if (e!==healer && e.active && e.hp < e.maxHp) {
                        let dist = Math.abs(e.x - healer.x) + Math.abs(e.y - healer.y);
                        if (dist < 60) e.hp++;
                    }
                });
            }
            triggerBomb(x, y) {
                this.playSound('explosion');
                this.enemies.forEach(e => {
                    if (e.active && Utils.checkCircleRect({x,y,r:150}, e)) {
                        e.active = false;
                        this.spawnExplosion(e.x, e.y);
                        this.addScore(e.type);
                    }
                });
                this.bullets = this.bullets.filter(b => !b.isEnemy);
            }
            playerHit() {
                if (this.player.shield) { this.player.shield = false; return; }
                this.lives--;
                this.spawnExplosion(this.player.x, this.player.y);
                if (this.lives <= 0) this.gameOver();
            }
            addScore(type) {
                const vals = { [TYPES.ARMORED]: 30, [TYPES.SHOOTER]: 50, [TYPES.SPLITTER]: 20 };
                this.score += (vals[type] || 10);
            }
            gameOver() {
                this.state = 'GAMEOVER';
                if (this.score > this.highscore) {
                    this.highscore = this.score;
                    localStorage.setItem('nokia_bs_highscore', this.highscore);
                }
                document.getElementById('go-score').innerText = this.score;
                document.getElementById('go-highscore').innerText = this.highscore;
                document.getElementById('gameover-screen').classList.add('active');
            }
            showMenu() {

                this.state = 'MENU';
                document.querySelectorAll('.screen').forEach(el => el.classList.remove('active'));
                document.getElementById('start-screen').classList.add('active');
            }
            playSound(type) {
                try {
                    if (type === 'shoot') {
                        const audio = document.getElementById('shootSound');
                        audio.pause();  // Pause tr∆∞·ªõc (an to√†n)
                        audio.currentTime = 0;  // Reset
                        audio.play().catch(e => {});  // B·∫Øt l·ªói Promise, kh√¥ng spam console
                    } else if (type === 'explosion') {
                        const audio = document.getElementById('explodeSound');
                        audio.pause();
                        audio.currentTime = 0;
                        audio.play().catch(e => {});  // B·∫Øt l·ªói
                    } else if (type === 'powerup') {
                        // Gi·ªØ √¢m thanh synth c≈© (kh√¥ng b·ªã l·ªói n√†y)
                        const osc = this.audioCtx.createOscillator();
                        const gain = this.audioCtx.createGain();
                        osc.connect(gain); gain.connect(this.audioCtx.destination);
                        const t = this.audioCtx.currentTime;
                        osc.type = 'square'; 
                        osc.frequency.setValueAtTime(440, t);
                        osc.frequency.setValueAtTime(880, t+0.1);
                        gain.gain.setValueAtTime(0.05, t); 
                        gain.gain.linearRampToValueAtTime(0, t+0.2);
                        osc.start(); osc.stop(t+0.2);
                    }
                } catch(e) {
                    console.log('Audio error:', e);
                }
            }
            
            showShop() {
                this.state = 'SHOP';
                document.querySelectorAll('.screen').forEach(el => el.classList.remove('active'));
                document.getElementById('shop-screen').classList.add('active');
                document.getElementById('shop-coins').innerText = this.coins;

                const list = document.getElementById('ship-list');
                list.innerHTML = '';
                list.style.cssText = 'display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px;padding:8px';

                SHIPS.forEach(ship => {
                    const srcAttr = ship.img ? (ship.img.getAttribute('src') || ship.img.src) : '';
                    const imgSrc = srcAttr && srcAttr.startsWith('/') ? srcAttr.slice(1) : srcAttr;

                    const owned = this.unlockedShips.includes(ship.id);
                    const equipped = this.currentShipId === ship.id;
                    const card = document.createElement('div');
                    card.className = 'shop-card';
                    // Centered image only; click opens modal with details
                    let badgeHtml = '';
                    if (equipped) badgeHtml = '<div class="equip-badge">‚úì</div>';
                    else if (owned) badgeHtml = '<div class="equip-badge" style="background:#9bbc0f;color:#092">‚úì</div>';
                    else badgeHtml = '';
                    card.innerHTML = `
                        ${badgeHtml}
                        <img src="${imgSrc}" class="shop-img" alt="${ship.name}">
                        <div style="margin-top:6px;font-size:10px;color:var(--nokia-light)">${ship.name}</div>
                        <div style="margin-top:4px;font-size:10px;color:#dff5b8">${ship.price===0?'FREE':ship.price+' ‚óé'}</div>
                    `;
                    card.addEventListener('click', () => this.showShipModal(ship.id));
                    list.appendChild(card);
                    // If badge exists on the card, make it interactive: equip on click/touch
                    const badge = card.querySelector('.equip-badge');
                    if (badge) {
                        const onBadge = (e) => {
                            e.stopPropagation();
                            // If ship is not owned and costs > 0, do nothing (or we could open modal)
                            if (!this.unlockedShips.includes(ship.id)) return;
                            this.equipShip(ship.id);
                        };
                        badge.addEventListener('click', onBadge);
                        // support touch on mobile
                        badge.addEventListener('touchstart', (e) => { e.preventDefault(); onBadge(e); }, { passive: false });
                    }
                });
            }

            buyShip(id) {
                const ship = SHIPS[id];
                if(this.coins >= ship.price && !this.unlockedShips.includes(id)) {
                    this.coins -= ship.price;
                    this.unlockedShips.push(id);
                    localStorage.setItem('nokia_bs_coins', this.coins);
                    localStorage.setItem('nokia_bs_ships', JSON.stringify(this.unlockedShips));
                    this.showShop();
                }
            }

            showShipModal(id) {
                const ship = SHIPS[id];
                const modal = document.getElementById('ship-modal');
                if (!modal) return;
                const img = modal.querySelector('.modal-img');
                const nameEl = modal.querySelector('.modal-name');
                const priceEl = modal.querySelector('.modal-price');
                const statsEl = modal.querySelector('.modal-stats');
                const actions = modal.querySelector('.modal-actions');
                const srcAttr = ship.img ? (ship.img.getAttribute('src') || ship.img.src) : '';
                const imgSrc = srcAttr && srcAttr.startsWith('/') ? srcAttr.slice(1) : srcAttr;
                img.src = imgSrc;
                nameEl.innerText = ship.name;
                priceEl.innerText = ship.price===0 ? 'FREE' : ship.price + ' ‚óé';
                statsEl.innerText = `Speed: ${ship.speed}  Fire: ${ship.fireRate}`;
                actions.innerHTML = '';
                if (this.currentShipId === id) {
                    // Don't show the circular tick in the modal ‚Äî show a simple label instead
                    const lbl = document.createElement('div');
                    lbl.innerText = 'EQUIPPED';
                    lbl.style.color = '#ffd54f';
                    lbl.style.fontSize = '12px';
                    actions.appendChild(lbl);
                } else if (this.unlockedShips.includes(id)) {
                    const btn = document.createElement('button');
                    btn.className = 'ui-btn shop-btn';
                    btn.innerText = 'EQUIP';
                    btn.onclick = () => { this.equipShip(id); this.hideShipModal(); };
                    // make EQUIP text yellow for visibility
                    btn.style.color = '#ffd54f';
                    actions.appendChild(btn);
                } else if (this.coins >= ship.price) {
                    const btn = document.createElement('button');
                    btn.className = 'ui-btn shop-btn';
                    btn.innerText = 'BUY';
                    btn.onclick = () => { this.buyShip(id); this.hideShipModal(); };
                    actions.appendChild(btn);
                } else {
                    const span = document.createElement('div');
                    span.style.color = '#555';
                    span.innerText = 'LOCKED';
                    actions.appendChild(span);
                }
                // make CLOSE button text yellow for visibility
                const closeBtn = modal.querySelector('button[onclick="game.hideShipModal()"]');
                if (closeBtn) closeBtn.style.color = '#ffd54f';
                modal.style.display = 'flex';
            }

            hideShipModal() {
                const modal = document.getElementById('ship-modal');
                if (modal) modal.style.display = 'none';
            }

            equipShip(id) {
                this.currentShipId = id;
                this.currentShip = SHIPS[id];
                localStorage.setItem('nokia_bs_current', id);
                this.showShop();
            }

            loop(t) {
                if (this.state !== 'PLAYING') return;
                this.update();
                this.draw();
                requestAnimationFrame(tm => this.loop(tm));
            }
        }
        const SHIPS = [
            { id: 0, name: "Classic",  price: 0,      speed: 3,   fireRate: 300, piercing: false, img: document.getElementById('ship0') },
            { id: 1, name: "Falcon",   price: 3000,   speed: 4,   fireRate: 250, piercing: false, img: document.getElementById('ship1') },
            { id: 2, name: "Viper",    price: 6000,   speed: 4.5, fireRate: 200, piercing: true,  img: document.getElementById('ship2') },
            { id: 3, name: "Phantom",  price: 12000,  speed: 5,   fireRate: 180, piercing: true,  img: document.getElementById('ship3') },
            { id: 4, name: "Raptor",   price: 20000,  speed: 5.5, fireRate: 150, piercing: true,  img: document.getElementById('ship4') },
            { id: 5, name: "Tempest",  price: 35000,  speed: 6,   fireRate: 120, piercing: true,  img: document.getElementById('ship5') }
        ];

        // === 6 LO·∫†I M√ÅY BAY ƒê·ªäCH ===
        const ENEMY_SHIPS = [
            { id: 0, scale: 0.12, colors: { body: '#8bac0f', wing: '#306230' } },
            { id: 1, scale: 0.14, colors: { body: '#ff6b6b', wing: '#ff8e8e' } },
            { id: 2, scale: 0.10, colors: { body: '#4ecdc4', wing: '#44a08d' } },
            { id: 3, scale: 0.16, colors: { body: '#45b7d1', wing: '#96c93d' } },
        ];
        const game = new Game();
    </script>
</body>
</html>